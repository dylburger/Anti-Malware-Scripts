#!/usr/bin/env bash

# Retrieves the latest anti-malware programs and definitions on http://tcdb/tools, then copies them into our HD flash drives. This script will only work on a Linux system

# Copyright (C) 2011 Dylan J. Sather

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

SOURCE_URL=http://tcdb.grinnell.edu/tools
DOWNLOAD_DIR=/home/helpdesk/AntiMalware
ADMIN_EMAIL='helpdesk@grinnell.edu'

# Set Internal Field Separator variable to account for spaces in drive names
IFS=$'\n'

# First, use cURL to get the files we need
curl $SOURCE_URL/AntiMalware/malwarebytes.zip -o $DOWNLOAD_DIR/malwarebytes.zip
curl $SOURCE_URL/AntiMalware/sas.zip -o $DOWNLOAD_DIR/sas.zip
curl $SOURCE_URL/AntiMalware/adaware.zip -o $DOWNLOAD_DIR/adaware.zip
curl $SOURCE_URL/AntiMalware/spybot.zip -o $DOWNLOAD_DIR/spybot.zip
curl $SOURCE_URL/AntiMalware/Autoruns.zip -o $DOWNLOAD_DIR/Autoruns.zip
curl $SOURCE_URL/AntiMalware/sysclean-package.zip -o $DOWNLOAD_DIR/sysclean-package.zip
curl $SOURCE_URL/AntiMalware/fsbl.exe -o $DOWNLOAD_DIR/fsbl.exe
curl $SOURCE_URL/AntiMalware/RootkitRevealer.zip -o $DOWNLOAD_DIR/RootkitRevealer.zip
curl $SOURCE_URL/AntiMalware/HJTInstall.exe -o $DOWNLOAD_DIR/HiJackThis.exe
curl $SOURCE_URL/logs/download.log -o $DOWNLOAD_DIR/download.log

# Do some unzipping and cleanup
cd $DOWNLOAD_DIR

files=( malwarebytes.zip sas.zip adaware.zip spybot.zip sysclean-package.zip )

for file in ${files[@]}; do
  unzip $file
  rm $file
done

unzip RootkitRevealer.zip
rm RootkitRevealer.zip RootkitRevealer.chm Eula.txt
unzip Autoruns.zip
rm Autoruns.zip autoruns.chm autorunsc.exe Eula.txt
unzip ProcessExplorer.zip
rm ProcessExplorer.zip procexp.chm Eula.txt

# Now, do the moving

# We want to count the drives we update and store their names in an array, which are sent in an e-mail report
count=0
drives=()

# For each drive that is of file system type vfat (FAT16, 32, etc.)...
for DRIVE in `df -t vfat | awk '{print $6}' | grep "^/"`; do
  drives[$count]=$DRIVE
  let "count += 1"

  # Check to see if our arbitrary large dummyFile exists; if so, delete it
  if [ -e $DRIVE/dummyFile ]; then
    rm $DRIVE/dummyFile
  fi

  # Check to see if AntiMalware directory is there, and if it isn't, create it
  if ! [ -d $DRIVE/AntiMalware ]; then
    mkdir $DRIVE/AntiMalware
  fi

  for FILE in $( ls $DOWNLOAD_DIR ); do
    # First, check to see if the file exists before copying
    if [ -e $DRIVE/AntiMalware/$FILE ]; then
      # If it does, check to see if it's newer than the one we have
      if [ $FILE -nt $DRIVE/AntiMalware/$FILE ]; then
	cp $DOWNLOAD_DIR/$FILE $DRIVE/AntiMalware/
	echo "Copying $FILE to $DRIVE"
      else 
	echo "We already have the most recent version of $FILE"
      fi
    else
      cp $DOWNLOAD_DIR/$FILE $DRIVE/AntiMalware/
      echo "Copying $FILE to $DRIVE, since it doesn't yet exist"
    fi
  done

  # We also want to remove any old lpt$???.zip archives...

  # If we have more than one 'lpt' file (i.e. Sysclean defs), proceed to remove all but the newest set of defs
  if [ `ls lpt* | wc -l` -gt 1 ]; then
    echo "Removing old Sysclean defs..."
    NEWEST_DEF_NUM=`ls -t lpt* | head -1 | grep -o "[0-9]\{1,\}"`
    ls lpt* | grep -v $NEWEST_DEF_NUM | xargs rm
  fi

  # ... and any old MBAM rules
  if [ `ls rules.*.ref | wc -l` -gt 1 ]; then
    echo "Removing old MBAM rules..."
    NEWEST_RULE_NUM=`ls -t rules.*.ref | head -1 | grep -o "[0-9]\{1,\}"`
    ls rules.*.ref | grep -v $NEWEST_RULE_NUM | xargs rm
  fi

  # Finally, we want to create a large dummyFile to fill the rest of the empty space on the drive; this has the practical effect of "write-protecting" the drive so that no malware can infect it
  echo "Creating dummy file..."
  dd if=/dev/zero of=$DRIVE/dummyFile bs=1024

done

# Create a grammatically correct message to send, based on the number of drives updated
case ${#drives[@]} in
    0 )
	message="No drives were updated" ;;
    1 )
	message="`basename ${drives[0]}` was updated successfully" ;;
    2 )
	message="`basename ${drives[0]}` and `basename ${drives[1]}` were both updated successfully" ;;
    * )
	for ((i=0; i < ${#drives[@]} - 1; i++)); do
	  if [ $i = 0 ]; then
	    message="`basename ${drives[$i]}`,"
	  else
	    message="${message} `basename ${drives[$i]}`,"
	  fi
	done

	message="${message} and `basename ${drives[$count - 1]}` were all updated successfully" ;;
esac

# Finally, clean up and send the e-mail
cd $DOWNLOAD_DIR
rm *

echo -e "$message\n\nIf you notice that a drive wasn't updated successfully, you should plug in the drive and run 'malware_updates.sh' from the Desktop of the Backup Server" | mail -s "Anti-Malware scripts complete" $ADMIN_EMAIL

exit 0
